var documenterSearchIndex = {"docs":
[{"location":"lib/api/","page":"API","title":"API","text":"Author = \"Brian Svoboda\"","category":"page"},{"location":"lib/api/#lib_api","page":"API","title":"API","text":"","category":"section"},{"location":"lib/api/","page":"API","title":"API","text":"Modules = [Jadex]","category":"page"},{"location":"lib/api/#Interface","page":"API","title":"Interface","text":"","category":"section"},{"location":"lib/api/","page":"API","title":"API","text":"Modules = [\n        Jadex.EscapeProbability,\n        Jadex.ReadData,\n        Jadex.Background,\n        Jadex.RunDefinition,\n        Jadex.Solver,\n        Jadex.GridRunner,\n]\nOrder   = [:module, :function, :type]","category":"page"},{"location":"lib/api/#Jadex.EscapeProbability.βlvg-Tuple{Any}","page":"API","title":"Jadex.EscapeProbability.βlvg","text":"βlvg(τ)\n\nExpanding sphere, Large Velocity Gradient, or Sobolev case. Formula from De Jong, Boland, and Dalgarno (1980, A&A 91, 68)[DeJong80].  Corrected by a factor of 2 in order to return 1 for τ=0. See Appendix B equation B-7.\n\n[DeJong80]: ADS abstract\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.EscapeProbability.βslab-Tuple{Any}","page":"API","title":"Jadex.EscapeProbability.βslab","text":"βslab(τ)\n\nSlab geometry (e.g. shocks) with power law approximations from De Jong, Dalgarno, and Chu (1975, ApJ 199, 69)[DeJong75].\n\n[DeJong75]: ADS abstract\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.EscapeProbability.βsphere-Tuple{Any}","page":"API","title":"Jadex.EscapeProbability.βsphere","text":"βsphere(τ)\n\nUniform sphere formula from Osterbrock (Astrophysics of Gaseous Nebulae and Active Galactic Nuclei) Appendix 2 with power law approximations for large and small optical depth.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.ReadData.parse_colliders-Tuple{Any, Any, Any}","page":"API","title":"Jadex.ReadData.parse_colliders","text":"parse_colliders(lines, levels, transitions)\n\nCollider collision rate terms are of the form:\n\n!NUMBER OF COLL PARTNERS\n1\n!COLLISIONS BETWEEN\n1  HCO+ - H2 from Flower (1999)\n!NUMBER OF COLL TRANS\n210\n!NUMBER OF COLL TEMPS\n12\n!COLL TEMPS\n   10.0   20.0   30.0   50.0   70.0  100.0  150.0  200.0  250.0  300.0  350.0  400.0\n!TRANS + UP + LOW + COLLRATES(cm^3 s^-1)\n    1     2     1  2.6e-10 2.3e-10 2.1e-10 2.0e-10 1.9e-10 1.8e-10 2.0e-10 2.2e-10 2.3e-10 2.5e-10 2.7e-10 2.8e-10\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.ReadData.parse_energies-Tuple{Any}","page":"API","title":"Jadex.ReadData.parse_energies","text":"parse_energies(lines)\n\nEnergy level terms begin on the 8th line and are of the form:\n\n!LEVEL + ENERGIES(cm^-1) + WEIGHT + J\n   1     0.000000000   1.0     0\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.ReadData.parse_table-Tuple{Any, Any}","page":"API","title":"Jadex.ReadData.parse_table","text":"parse_table(lines, types)\n\nParse a white-space delimited, fixed-width table into a set of columns with known data types.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.ReadData.parse_transitions-Tuple{Any, Jadex.ReadData.EnergyLevels}","page":"API","title":"Jadex.ReadData.parse_transitions","text":"parse_transitions(lines, levels::EnergyLevels)\n\nTransition terms are of the form:\n\n!TRANS + UP + LOW + EINSTEINA(s^-1) + FREQ(GHz) + E_u(K)\n    1     2     1  4.251e-05          89.18839570     4.28\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.ReadData.Specie-Tuple{AbstractString}","page":"API","title":"Jadex.ReadData.Specie","text":"Specie(name::AbstractString; datadir=datadir)\n\nParse the LAMDA collision rate file for an atomic or molecular specie from the filename stem (i.e., without the \".dat\" file extension). For example, the stem for the \"hco+@xpol.dat\" file would be \"hco+@xpol\".\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Background.blackbody_background-Tuple{Any}","page":"API","title":"Jadex.Background.blackbody_background","text":"blackbody_background(xnu; tbg::Real=TCMB)\n\nSet the background radiation field from a blackbody with a given background temperature. The default temperature is set for the CMB.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Background.calc_galactic_isrf-Tuple{Any}","page":"API","title":"Jadex.Background.calc_galactic_isrf","text":"calc_galactic_isrf(xnu; uv_scaling=1.0)\n\nGalactic interstellar radiation field (ISRF) as parametrized by Hocuk et al. (2017; \"H17\") in Appendix B based on Zucconi et al. (2001). Six weighted black-body components are used corresponding to the values in H17 Table B1. The UV component of the ISRF is based on Draine (1978) and added according to the polynomial in H17 Equation B2.\n\nThe angularly-integrated intensity J_ν is returned with units of erg / (s cm^2 sr Hz).\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Background.planck-Tuple{Any, Any}","page":"API","title":"Jadex.Background.planck","text":"planck(ΔE, tex)\n\nPlanck function to compute black body intensity in [erg / (s cm^2 Hz sr)].\n\nArguments\n\nΔE: Energy level difference in wavenumber [1/cm].\ntex: Excitation temperature in [K].\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Background.BackgroundField","page":"API","title":"Jadex.Background.BackgroundField","text":"BackgroundField(trj, backi, totalb)\n\nArguments\n\ntrj: Background brightness temperature [K] in the Rayleigh-Jeans limit.\nbacki: Background intensity (integrated, J_ν) in [erg / (s cm^2 Hz sr)].\ntotalb: Total background intensity. Note that because internal radiation           fields are not implemented, totalb should be identical to backi.\n\n\n\n\n\n","category":"type"},{"location":"lib/api/#Jadex.RunDefinition.get_collision_rates-Union{Tuple{F}, Tuple{Specie{F}, Dict, Real}} where F<:Real","page":"API","title":"Jadex.RunDefinition.get_collision_rates","text":"get_collision_rates(mol::Specie, densities::Dict, tkin::Real)\n\nInterpolate the collision rates for the kinetic temperature and sum over all colliders.\n\nReturns\n\ncrate::Matrix: Collision rate matrix (product of density and rate coeff.).\nctot::Vector: Total collision rate for all transitions to a level.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.RunDefinition.thermal_h2_density-Tuple{Any, Any}","page":"API","title":"Jadex.RunDefinition.thermal_h2_density","text":"thermal_h2_density(density, tkin)\n\nCalculate densities for the ortho (symmetric) and para (anti-symmetric) spin-isomers of molecular hydrogen (H2) from a total molecule density. The ortho-to-para ratio assumes that the H2 was formed in thermal equillibrium at the give kinetic temperature. In the high-temperature limit (> 100 K) the ortho-to-para ratio is 3.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Solver.calc_radiation_temperature-NTuple{4, Any}","page":"API","title":"Jadex.Solver.calc_radiation_temperature","text":"calc_radiation_temperature(xnu, tex, τl, intens_bg)\n\nCalculate the radiation peak temperature or the background-subtracted line intensity in units of the equivalent radiation temperature in the Rayleigh-Jeans limit. This is equivalent to an observed \"main beam\" antenna temperature T_mathrmmb (antenna temperature corrected for the aperture efficiency, spill-over, and atmospheric opacity) if the emission completely fills the beam (i.e., a beam filling fraction of 1).\n\nT_R = fracc^22 k nu^2 left( I^mathrmem_nu - I^mathrmbg_nu right)\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Solver.init_radiative!-Tuple{Solution, RunDef}","page":"API","title":"Jadex.Solver.init_radiative!","text":"On the first iteration, use the background intensity to estimate the level populations from optically thin statistical equillibrium. This assumes that the emission is optically thin by setting the escape probability β=1.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Solver.ng_accelerate!-Tuple{Solution}","page":"API","title":"Jadex.Solver.ng_accelerate!","text":"ng_accelerate!(sol::Solution)\n\nApply Ng-acceleration to level populations from previous three iterations.  See S4.4.7 of \"Radiative Transfer in Astrophysics: Theory, Numerical Methods, and Applications\" lecture note series by C.P. Dullemond which is itself based on Olson, Auer, and Buchler (1985).\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Solver.solve_rate_eq!-Tuple{Any, Any, Any}","page":"API","title":"Jadex.Solver.solve_rate_eq!","text":"solve_rate_eq!(xpop, yrate, rhs)\n\nSolve the system of linear equations for the excitation rates to and from each energy level. The result is computed using LU factorization and back-substition on the yrate matrix without pivoting.\n\nThe system of equations Y x = r is inverted to x = Y^-1 r and solved, where Y (yrate) is the rate matrix encoding the total rate of excitation/dexcitation from one level to another, x (xpop) is the level populations, and r is the right-hand side (rhs) expressing the time rate-of-change of the level populations. Statistical equillibrium assumes that the derivative rhs term is all zero except for the conservation equation.\n\nNotes\n\nThese operations correspond to the LU factorization subroutines ludcmp (lower-upper decomposition) and lubksb (lower-upper back substition) Fortran functions in the F77 RADEX source code matrix.f and slatec.f. In practice these subroutines simply prepare (and copy) the arguments for the subroutine SGEIR, which does both the decomposition and solution through back-substitution.  In lubksb, the equation for the last energy level is over-written with the conservation equation (i.e., ones) to make the rate matrix square and non-singular (otherwise the last \"column\" would be all zeros). This is also done here by over-writing the rates in-place with ones.\n\nThe LU factorization lu! replaces yrate in-place and returns a view. Some work products are still generated with LAPACK/BLAS, but benchmarking shows that these impose negligible overhead.\n\nA more rigorous factorization would be to include the conservation equation as an additional row and solve the rectangular system of equations (m+1m). This is also what DESPOTIC does using the non-negative least squares (nnls) solver. Tests with QR factorization and Gaussian elimination however were less numerically stable than LU factorization as well as a factor of a few slower.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Solver.solve_rate_eq_reduced!-Tuple{Any, Any, Any}","page":"API","title":"Jadex.Solver.solve_rate_eq_reduced!","text":"solve_rate_eq_reduced!(xpop, yrate, nr)\n\nSolve the rate equation for a restricted/reduced number of levels. Levels higher than nr are assumed to be optically thin and only coupled by radiative processes. A cascade to levels less than or equal to nr is computed for higher-lying transitions.\n\nThis formalism may not be strictly accurate for complex molecules (e.g., mathrmCH_3OH) where many transitions between levels may be radiatively forbidden.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Solver.step_collision!-Tuple{Solution, RunDef}","page":"API","title":"Jadex.Solver.step_collision!","text":"step_collision!(sol::Solution, rdf::RunDef)\n\nCompute contribution of collisional processes to the rate matrix. Modifies the Solution in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Solver.step_radiative!-Tuple{Solution, RunDef}","page":"API","title":"Jadex.Solver.step_radiative!","text":"step_radiative!(sol::Solution, rdf::RunDef)\n\nCompute contribution of radiative processes to the rate matrix using the escape probability. Modifies the Solution in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.Solver.step_tau_tex!-Tuple{Solution, RunDef}","page":"API","title":"Jadex.Solver.step_tau_tex!","text":"step_tau_tex!(sol::Solution, rdf::RunDef)\n\nCompute the optical depth and excitation temperature for each line.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.GridRunner.get_interp-Tuple{AbstractArray{<:Real}, Any}","page":"API","title":"Jadex.GridRunner.get_interp","text":"get_interp(A::Matrix, axes; B=<interpolation-type>)\n\nGenerate a 5D interpolation object for a given τ or Tₑₓ cube where the last dimension indexes the transition number. By default a second order (quadratic) interpolation is used with flat extrapolation for out-of-bounds access. The axis containing the transition number is not interpolated – an exactly matching value must be given.\n\nPlease ensure that the axes passed have a linear step size (nb. use log(n) or log(N) axes if using logarithmically spaced values). A gridded interpolation object can be created using the Gridded interpolation type.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.GridRunner.interp_errors-NTuple{4, Any}","page":"API","title":"Jadex.GridRunner.interp_errors","text":"Compare the interpolation to a uniform random sample and return an array of the deviations.\n\nNote that this implementation currently only works for 5 parameter grids of (n, Tₖ, N, Δv, j) and where n is the volume density of the specified collision partner.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.GridRunner.rungrid-Union{Tuple{I}, Tuple{Specie, AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector{I}}} where I<:Integer","page":"API","title":"Jadex.GridRunner.rungrid","text":"rungrid(mol, density, tkin, cdmol, deltav, transitions; ...)\n\nGenerate a grid of τ and Tₑₓ values over the set of physical conditions and selected transitions. Most parameters for a RunDef run definition can be set as keyword arguments (e.g., β, bg). Arguments can be passed as scalars or collections. Runs will be executed in parallel if Julia was started with multiple threads.\n\nResulting cubes are indexed with shape (n, Tₖ, N, δv, j) for volume density, kinetic temperature, column density, linewidth, and transition number. The transition index number corresponds to the TRANS value in the LAMDA data file or the index number in the output table.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.GridRunner.runseq-Tuple{Solution, AbstractVector{<:RunDef}}","page":"API","title":"Jadex.GridRunner.runseq","text":"runseq(sol, rdfs; ...)\n\nExecute a series model definitions. All RunDef run definitions should be for the same Specie type (i.e., LAMDA file).\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Wrapper-for-slatec.f","page":"API","title":"Wrapper for slatec.f","text":"","category":"section"},{"location":"lib/api/","page":"API","title":"API","text":"Modules = [Jadex.WrapSlateC]\nOrder   = [:module, :function, :type]","category":"page"},{"location":"lib/api/#Jadex.WrapSlateC","page":"API","title":"Jadex.WrapSlateC","text":"Wrap SLATEC\n\nWrap the slatec.f Fortran file distributed as part of RADEX. The slatec.f library is used to solve the system of equations for statistical equillibrium and return the populations for each level. The rate matrix is factored into lower and upper diagonal components (LU decomposition) and solved using partial-pivoting. The subroutines ludcmp (LU decompose) and lubksb (LU back-substition) format the inputs for the main SGEIR subroutine, which itself calls the LINPACK subroutines SGEFA and SGESL.\n\nThe Julia standard library includes LINPACK and uses LU-decomposition with partial-pivoting as the default algorithm for matrix inversion when calling A \\ b, thus this module is not necessary but included for the purposes of verifying the output against the exact output of RADEX.\n\nUsage\n\nFirst compile the slatec.f file distributed in the src directory of RADEX into a shared library libslatec.so:\n\n    gfortran -shared -O2 slatec.f -o libslatec.so -fPIC\n\nThe Fortran standard does not specify how symbol names are expressed in shared libraries and are mangled in different ways by different compilers and even versions of the same compiler. To check, use the nm program to list symbol names from the object file:\n\n    nm libslatec.so\n\nLook for entries in the output of nm that are similar to \"ludcmp\" and \"lubksb\". The gfortran compiler typically appends an underscore to the symbol name, thus ludcmp_ and lubksb_. If these are not the names, then this file will need to edited to reflect those names, as Julia's ccall must be given literals for the symbol, library name, output type, and input types (although this could be avoided with a macro that replaces these values at compile time).\n\nFinally, ensure that the directory containing the library file is included in the shell environment variable LD_LIBRARY_PATH:\n\n    # Run before starting Julia or include in shell configuration.\n    export LD_LIBRARY_PATH=<path-to-lib>:$LD_LIBRARY_PATH\n    # Or include when starting Julia.\n    LD_LIBRARY_PATH=<path-to-lib> julia\n\nTo use, call the call_slatec! function to modify the rhs level population work array in-place.\n\n\n\n\n\n","category":"module"},{"location":"lib/api/#Jadex.WrapSlateC.call_slatec!-Tuple{Matrix{Float64}, Vector{Float64}}","page":"API","title":"Jadex.WrapSlateC.call_slatec!","text":"call_slatec!(yrate, rhs)\n\nSolve the system of equations in yrate using LU-decomposition and partial-pivoting to perform the matrix inversion operation yrate \\ rhs. The results are stored by modifying the vector rhs in-place. The Fortran routines in RADEX are called natively and included for verification purposes.\n\n\n\n\n\n","category":"method"},{"location":"lib/api/#Jadex.WrapSlateC.solve_rate_eq_slatec!-Tuple{Any, Any, Any}","page":"API","title":"Jadex.WrapSlateC.solve_rate_eq_slatec!","text":"For testing results with LU factorization as used by RADEX.\n\n\n\n\n\n","category":"method"},{"location":"install/","page":"Installation","title":"Installation","text":"Author = \"Brian Svoboda\"","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To install Jadex, open a Julia interactive session (see the Julia documentation's Getting Started page for further instructions) and then enter the package management mode by entering ] and then add Jadex:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n\npkg> add Jadex","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"and, optionally, to run the test suite call:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> test Jadex","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Alternatively, to install from the main branch hosted on GitHub, call:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add https://github.com/autocorr/autocorr/Jadex.jl","category":"page"},{"location":"install/#Installing-in-Python","page":"Installation","title":"Installing in Python","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To call Jadex from Python we can use the PyJulia Python package to call-out to our Julia environment. Following the PyJulia installation instructions:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(1) Ensure that Julia is installed and that the Julia executable is in one's PATH (a symbolic link is okay but not an alias).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(2) Install Jadex within Julia (see the previous section above).","category":"page"},{"location":"install/#Python-installation-without-Anaconda","page":"Installation","title":"Python installation without Anaconda","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Now we need to install PyJulia, which can be imported as the Python julia module. If your system uses Anaconda, then please see the alternate instructions in the following section.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(3a) Install PyJulia in Python by calling python3 -m pip install --user julia from the command line.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(4a) Install the Julia dependencies of PyJulia (i.e., PyCall) from within Python by calling:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"import julia\njulia.install()","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To import Jadex and call it, run:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"from julia import Jadex\nmol = Jadex.Specie(\"hco+@xpol\", datadir=\"path/to/data\")","category":"page"},{"location":"install/#Python-installation-with-Anaconda","page":"Installation","title":"Python installation with Anaconda","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If using Anaconda, we need to mitigate a known limitation of PyJulia/PyCall for distributions of Python that use static linking, which is the case for Anaconda (see PyJulia's Troubleshooting page for more details).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(3b) Install PyJulia in Python by calling pip install julia from the conda environment you wish to use (i.e., after calling conda activate myenv or similar).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(4b) Before using PyJulia (i.e., import julia), turn off the Julia module compilation cache and then install the Julia dependencies of PyJulia:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"from julia.api import Julia\njl = Julia(compiled_modules=False)\nimport julia\njulia.install()","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"note: Note\nUnfortunately turning off module compilation and cacheing adds some initial startup overhead because pre-compiled modules can't be re-used. This is not so bad for Jadex, however, but would be more problematic if one was calling Julia modules for plotting.","category":"page"},{"location":"userguide/","page":"User Guide","title":"User Guide","text":"Author = \"Brian Svoboda\"","category":"page"},{"location":"userguide/#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"userguide/","page":"User Guide","title":"User Guide","text":"note: Note\nUnder construction.","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"Author = \"Brian Svoboda\"","category":"page"},{"location":"#Jadex","page":"Jadex","title":"Jadex","text":"","category":"section"},{"location":"","page":"Jadex","title":"Jadex","text":"High-performance and extensible re-implementation of the Fortran 77 code RADEX (van der Tak et al. 2007, A&A 468, 627) in the Julia programming language. A Python wrapper is provided using PyJulia.","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"Jadex & RADEX are non-LTE radiative transfer codes for calculating atomic and molecular spectral line intensities. They assume a uniform medium (i.e., single zone) with energy level populations in statistical equillibrium. Optical depth is calculated using an escape probability defined for different cloud geometries (e.g., LVG, uniform sphere, slab).","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"For cases where the same input parameters and constants are used, results from Jadex should match RADEX to within a tolerance of five significant figures. When using an un-patched copy of RADEX values are expected to match within four significant figures due to higher precision mathematical constants in Jadex. Jadex has been validated against the RADEX wrapper SpectralRadex for a suite of species and physical conditions (see test/validation.jl).","category":"page"},{"location":"#Package-features","page":"Jadex","title":"Package features","text":"","category":"section"},{"location":"","page":"Jadex","title":"Jadex","text":"Improved performance (~110x).\nImproved convergence rate through Ng-acceleration\nUser definable escape probability and background radiation field.\nMulti-threaded parameter grid calculations with interpolation.\nCross-platform: tested on Linux, MacOS, and Windows.\nPython interface provided using PyJulia.\nTest and validation suite.\nExtensible design.","category":"page"},{"location":"#Installing","page":"Jadex","title":"Installing","text":"","category":"section"},{"location":"","page":"Jadex","title":"Jadex","text":"To install Jadex, open an interactive Julia session, press the ] key to enter the package management mode, and execute the command add Jadex. For further instructions, see the Installation page.","category":"page"},{"location":"#Quickstart-guide","page":"Jadex","title":"Quickstart guide","text":"","category":"section"},{"location":"","page":"Jadex","title":"Jadex","text":"First download the spectroscopic and collision rate data .dat files from LAMDA for the specie(s) of interest. Import the functions and types from Jadex into the namespace by executing:","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"using Jadex","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"Now read and parse the LAMDA file into a Specie object. The identifier passed to Specie should be the same as the file name except with the .dat extension removed. Thus for the hco+@xpol.dat file, use the identifier hco+@xpol. After downloading the file, it is worth occasionally checking LAMDA for updates.","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"mol = Specie(\"hco+@xpol\", datadir=\"path/to/LAMDA/files\")","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"Note that Julia is a JIT-compiled language, and so the first execution will have significant run-time overhead due to code compilation. In Jadex, the majority of the overhead occurs when calling Specie because the CSV.jl and DataFrames.jl libraries used to parse the LAMDA rate files are large. Subsequent executions will be much faster.","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"Next define the physical properties of the run. The default escape probability geometry is the expanding (or collapsing) sphere using the \"large velocity gradient\" (LVG) approximation. The default background radiation field is a blackbody with the CMB temperature.","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"rdf = RunDef(mol, density=Dict(\"h2\" => 1e4), tkin=20.0, cdmol=1e13, deltav=1.0)","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"Now solve for the level populations, optical depths, and excitation temperatures for all transitions. Emergent radiation temperatures and integrated intensities are then calculated for all transitions within the selected frequency range.","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"df = get_results(rdf, freq_max=500)  # GHz","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"Results are returned in a DataFrame object. Please refer to the DataFrames.jl documentation for further information on working with DataFrames.","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"Please refer to the User Guide for additional information regarding running and using Jadex.","category":"page"},{"location":"#Citing-this-work","page":"Jadex","title":"Citing this work","text":"","category":"section"},{"location":"","page":"Jadex","title":"Jadex","text":"If you use Jadex in an academic work, we request that you cite the following references, including the original publication for RADEX (van der Tak et al. 2007):","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"@ARTICLE{2007A&A...468..627V,\n       author = {{van der Tak}, F.~F.~S. and {Black}, J.~H. and {Sch{\\\"o}ier}, F.~L. and {Jansen}, D.~J. and {van Dishoeck}, E.~F.},\n        title = \"{A computer program for fast non-LTE analysis of interstellar line spectra. With diagnostic plots to interpret observed line intensity ratios}\",\n      journal = {\\aap},\n     keywords = {radiative transfer, methods: numerical, radio lines: ISM, infrared: ISM, submillimeter, Astrophysics},\n         year = 2007,\n        month = jun,\n       volume = {468},\n       number = {2},\n        pages = {627-635},\n          doi = {10.1051/0004-6361:20066820},\narchivePrefix = {arXiv},\n       eprint = {0704.0155},\n primaryClass = {astro-ph},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2007A&A...468..627V},\n      adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"If one uses the collision rate files from the LAMDA database, the following citation should be included in addition to the source references listed on the page for the specie(s) used.","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"@ARTICLE{2005A&A...432..369S,\n       author = {{Sch{\\\"o}ier}, F.~L. and {van der Tak}, F.~F.~S. and {van Dishoeck}, E.~F. and {Black}, J.~H.},\n        title = \"{An atomic and molecular database for analysis of submillimetre line observations}\",\n      journal = {\\aap},\n     keywords = {astronomical data bases: miscellaneous, atomic data, molecular data, radiative transfer, ISM: atoms, ISM: molecules, Astrophysics},\n         year = 2005,\n        month = mar,\n       volume = {432},\n       number = {1},\n        pages = {369-379},\n          doi = {10.1051/0004-6361:20041729},\narchivePrefix = {arXiv},\n       eprint = {astro-ph/0411110},\n primaryClass = {astro-ph},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2005A&A...432..369S},\n      adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}","category":"page"},{"location":"#Similar-tools","page":"Jadex","title":"Similar tools","text":"","category":"section"},{"location":"","page":"Jadex","title":"Jadex","text":"Other similar tools for calculating spectral line intensities include:","category":"page"},{"location":"","page":"Jadex","title":"Jadex","text":"RADEX: Single-zone, non-LTE radiative transfer code written in Fortran 77.\npyradex: Python interface to RADEX with Fortran bindings auto-generated by f2py.\nSpectralRadex: Python interface to RADEX with Fortran bindings auto-generated by f2py, grid evaluation, and creation of model spectra.\nmyradex: Single-zone, non-LTE radiative transfer code written in Fortran 90. Level populations are computed using an ODE solver.\nndradex: Command-line wrapper for the RADEX executable designed for evaluating parameter grids.\nDESPOTIC: Python package to perform calculations related to line emission and thermal behavior in cold interstellar clouds.\nMOLPOP-CEP: Multi-zone model using the coupled escape probability (CEP) method.","category":"page"},{"location":"#License-and-Acknowledgements","page":"Jadex","title":"License and Acknowledgements","text":"","category":"section"},{"location":"","page":"Jadex","title":"Jadex","text":"Copyright Brian Svoboda (2021) and distributed under the terms of the GPL v3 software license. RADEX is authored by Floris van der Tak and contributors.","category":"page"}]
}
